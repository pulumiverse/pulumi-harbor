// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package harbor

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-harbor/sdk/v3/go/harbor/internal"
)

// ## Example Usage
type GarbageCollection struct {
	pulumi.CustomResourceState

	// Allow garbage collection on untagged artifacts.
	DeleteUntagged pulumi.BoolPtrOutput `pulumi:"deleteUntagged"`
	// Sets the schedule how often the Garbage Collection will run.  Can be to `"hourly"`, `"daily"`, `"weekly"` or can be a custom cron string ie, `"0 5 4 * * *"`
	Schedule pulumi.StringOutput `pulumi:"schedule"`
	// Number of workers to run the garbage collection, value must be between 1 and 5.
	Workers pulumi.IntPtrOutput `pulumi:"workers"`
}

// NewGarbageCollection registers a new resource with the given unique name, arguments, and options.
func NewGarbageCollection(ctx *pulumi.Context,
	name string, args *GarbageCollectionArgs, opts ...pulumi.ResourceOption) (*GarbageCollection, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Schedule == nil {
		return nil, errors.New("invalid value for required argument 'Schedule'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource GarbageCollection
	err := ctx.RegisterResource("harbor:index/garbageCollection:GarbageCollection", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGarbageCollection gets an existing GarbageCollection resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGarbageCollection(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GarbageCollectionState, opts ...pulumi.ResourceOption) (*GarbageCollection, error) {
	var resource GarbageCollection
	err := ctx.ReadResource("harbor:index/garbageCollection:GarbageCollection", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering GarbageCollection resources.
type garbageCollectionState struct {
	// Allow garbage collection on untagged artifacts.
	DeleteUntagged *bool `pulumi:"deleteUntagged"`
	// Sets the schedule how often the Garbage Collection will run.  Can be to `"hourly"`, `"daily"`, `"weekly"` or can be a custom cron string ie, `"0 5 4 * * *"`
	Schedule *string `pulumi:"schedule"`
	// Number of workers to run the garbage collection, value must be between 1 and 5.
	Workers *int `pulumi:"workers"`
}

type GarbageCollectionState struct {
	// Allow garbage collection on untagged artifacts.
	DeleteUntagged pulumi.BoolPtrInput
	// Sets the schedule how often the Garbage Collection will run.  Can be to `"hourly"`, `"daily"`, `"weekly"` or can be a custom cron string ie, `"0 5 4 * * *"`
	Schedule pulumi.StringPtrInput
	// Number of workers to run the garbage collection, value must be between 1 and 5.
	Workers pulumi.IntPtrInput
}

func (GarbageCollectionState) ElementType() reflect.Type {
	return reflect.TypeOf((*garbageCollectionState)(nil)).Elem()
}

type garbageCollectionArgs struct {
	// Allow garbage collection on untagged artifacts.
	DeleteUntagged *bool `pulumi:"deleteUntagged"`
	// Sets the schedule how often the Garbage Collection will run.  Can be to `"hourly"`, `"daily"`, `"weekly"` or can be a custom cron string ie, `"0 5 4 * * *"`
	Schedule string `pulumi:"schedule"`
	// Number of workers to run the garbage collection, value must be between 1 and 5.
	Workers *int `pulumi:"workers"`
}

// The set of arguments for constructing a GarbageCollection resource.
type GarbageCollectionArgs struct {
	// Allow garbage collection on untagged artifacts.
	DeleteUntagged pulumi.BoolPtrInput
	// Sets the schedule how often the Garbage Collection will run.  Can be to `"hourly"`, `"daily"`, `"weekly"` or can be a custom cron string ie, `"0 5 4 * * *"`
	Schedule pulumi.StringInput
	// Number of workers to run the garbage collection, value must be between 1 and 5.
	Workers pulumi.IntPtrInput
}

func (GarbageCollectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*garbageCollectionArgs)(nil)).Elem()
}

type GarbageCollectionInput interface {
	pulumi.Input

	ToGarbageCollectionOutput() GarbageCollectionOutput
	ToGarbageCollectionOutputWithContext(ctx context.Context) GarbageCollectionOutput
}

func (*GarbageCollection) ElementType() reflect.Type {
	return reflect.TypeOf((**GarbageCollection)(nil)).Elem()
}

func (i *GarbageCollection) ToGarbageCollectionOutput() GarbageCollectionOutput {
	return i.ToGarbageCollectionOutputWithContext(context.Background())
}

func (i *GarbageCollection) ToGarbageCollectionOutputWithContext(ctx context.Context) GarbageCollectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GarbageCollectionOutput)
}

// GarbageCollectionArrayInput is an input type that accepts GarbageCollectionArray and GarbageCollectionArrayOutput values.
// You can construct a concrete instance of `GarbageCollectionArrayInput` via:
//
//	GarbageCollectionArray{ GarbageCollectionArgs{...} }
type GarbageCollectionArrayInput interface {
	pulumi.Input

	ToGarbageCollectionArrayOutput() GarbageCollectionArrayOutput
	ToGarbageCollectionArrayOutputWithContext(context.Context) GarbageCollectionArrayOutput
}

type GarbageCollectionArray []GarbageCollectionInput

func (GarbageCollectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GarbageCollection)(nil)).Elem()
}

func (i GarbageCollectionArray) ToGarbageCollectionArrayOutput() GarbageCollectionArrayOutput {
	return i.ToGarbageCollectionArrayOutputWithContext(context.Background())
}

func (i GarbageCollectionArray) ToGarbageCollectionArrayOutputWithContext(ctx context.Context) GarbageCollectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GarbageCollectionArrayOutput)
}

// GarbageCollectionMapInput is an input type that accepts GarbageCollectionMap and GarbageCollectionMapOutput values.
// You can construct a concrete instance of `GarbageCollectionMapInput` via:
//
//	GarbageCollectionMap{ "key": GarbageCollectionArgs{...} }
type GarbageCollectionMapInput interface {
	pulumi.Input

	ToGarbageCollectionMapOutput() GarbageCollectionMapOutput
	ToGarbageCollectionMapOutputWithContext(context.Context) GarbageCollectionMapOutput
}

type GarbageCollectionMap map[string]GarbageCollectionInput

func (GarbageCollectionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GarbageCollection)(nil)).Elem()
}

func (i GarbageCollectionMap) ToGarbageCollectionMapOutput() GarbageCollectionMapOutput {
	return i.ToGarbageCollectionMapOutputWithContext(context.Background())
}

func (i GarbageCollectionMap) ToGarbageCollectionMapOutputWithContext(ctx context.Context) GarbageCollectionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GarbageCollectionMapOutput)
}

type GarbageCollectionOutput struct{ *pulumi.OutputState }

func (GarbageCollectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GarbageCollection)(nil)).Elem()
}

func (o GarbageCollectionOutput) ToGarbageCollectionOutput() GarbageCollectionOutput {
	return o
}

func (o GarbageCollectionOutput) ToGarbageCollectionOutputWithContext(ctx context.Context) GarbageCollectionOutput {
	return o
}

// Allow garbage collection on untagged artifacts.
func (o GarbageCollectionOutput) DeleteUntagged() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *GarbageCollection) pulumi.BoolPtrOutput { return v.DeleteUntagged }).(pulumi.BoolPtrOutput)
}

// Sets the schedule how often the Garbage Collection will run.  Can be to `"hourly"`, `"daily"`, `"weekly"` or can be a custom cron string ie, `"0 5 4 * * *"`
func (o GarbageCollectionOutput) Schedule() pulumi.StringOutput {
	return o.ApplyT(func(v *GarbageCollection) pulumi.StringOutput { return v.Schedule }).(pulumi.StringOutput)
}

// Number of workers to run the garbage collection, value must be between 1 and 5.
func (o GarbageCollectionOutput) Workers() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *GarbageCollection) pulumi.IntPtrOutput { return v.Workers }).(pulumi.IntPtrOutput)
}

type GarbageCollectionArrayOutput struct{ *pulumi.OutputState }

func (GarbageCollectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GarbageCollection)(nil)).Elem()
}

func (o GarbageCollectionArrayOutput) ToGarbageCollectionArrayOutput() GarbageCollectionArrayOutput {
	return o
}

func (o GarbageCollectionArrayOutput) ToGarbageCollectionArrayOutputWithContext(ctx context.Context) GarbageCollectionArrayOutput {
	return o
}

func (o GarbageCollectionArrayOutput) Index(i pulumi.IntInput) GarbageCollectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *GarbageCollection {
		return vs[0].([]*GarbageCollection)[vs[1].(int)]
	}).(GarbageCollectionOutput)
}

type GarbageCollectionMapOutput struct{ *pulumi.OutputState }

func (GarbageCollectionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GarbageCollection)(nil)).Elem()
}

func (o GarbageCollectionMapOutput) ToGarbageCollectionMapOutput() GarbageCollectionMapOutput {
	return o
}

func (o GarbageCollectionMapOutput) ToGarbageCollectionMapOutputWithContext(ctx context.Context) GarbageCollectionMapOutput {
	return o
}

func (o GarbageCollectionMapOutput) MapIndex(k pulumi.StringInput) GarbageCollectionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *GarbageCollection {
		return vs[0].(map[string]*GarbageCollection)[vs[1].(string)]
	}).(GarbageCollectionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GarbageCollectionInput)(nil)).Elem(), &GarbageCollection{})
	pulumi.RegisterInputType(reflect.TypeOf((*GarbageCollectionArrayInput)(nil)).Elem(), GarbageCollectionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GarbageCollectionMapInput)(nil)).Elem(), GarbageCollectionMap{})
	pulumi.RegisterOutputType(GarbageCollectionOutput{})
	pulumi.RegisterOutputType(GarbageCollectionArrayOutput{})
	pulumi.RegisterOutputType(GarbageCollectionMapOutput{})
}
