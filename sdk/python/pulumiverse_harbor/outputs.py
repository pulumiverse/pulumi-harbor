# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ReplicationFilter',
    'RetentionPolicyRule',
    'RobotAccountPermission',
    'RobotAccountPermissionAccess',
    'GetGroupsGroupResult',
    'GetProjectsProjectResult',
]

@pulumi.output_type
class ReplicationFilter(dict):
    def __init__(__self__, *,
                 decoration: Optional[str] = None,
                 labels: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 resource: Optional[str] = None,
                 tag: Optional[str] = None):
        ReplicationFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decoration=decoration,
            labels=labels,
            name=name,
            resource=resource,
            tag=tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decoration: Optional[str] = None,
             labels: Optional[Sequence[str]] = None,
             name: Optional[str] = None,
             resource: Optional[str] = None,
             tag: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if decoration is not None:
            _setter("decoration", decoration)
        if labels is not None:
            _setter("labels", labels)
        if name is not None:
            _setter("name", name)
        if resource is not None:
            _setter("resource", resource)
        if tag is not None:
            _setter("tag", tag)

    @property
    @pulumi.getter
    def decoration(self) -> Optional[str]:
        return pulumi.get(self, "decoration")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")


@pulumi.output_type
class RetentionPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysRetain":
            suggest = "always_retain"
        elif key == "mostRecentlyPulled":
            suggest = "most_recently_pulled"
        elif key == "mostRecentlyPushed":
            suggest = "most_recently_pushed"
        elif key == "nDaysSinceLastPull":
            suggest = "n_days_since_last_pull"
        elif key == "nDaysSinceLastPush":
            suggest = "n_days_since_last_push"
        elif key == "repoExcluding":
            suggest = "repo_excluding"
        elif key == "repoMatching":
            suggest = "repo_matching"
        elif key == "tagExcluding":
            suggest = "tag_excluding"
        elif key == "tagMatching":
            suggest = "tag_matching"
        elif key == "untaggedArtifacts":
            suggest = "untagged_artifacts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RetentionPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RetentionPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RetentionPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_retain: Optional[bool] = None,
                 disabled: Optional[bool] = None,
                 most_recently_pulled: Optional[int] = None,
                 most_recently_pushed: Optional[int] = None,
                 n_days_since_last_pull: Optional[int] = None,
                 n_days_since_last_push: Optional[int] = None,
                 repo_excluding: Optional[str] = None,
                 repo_matching: Optional[str] = None,
                 tag_excluding: Optional[str] = None,
                 tag_matching: Optional[str] = None,
                 untagged_artifacts: Optional[bool] = None):
        """
        :param bool always_retain: retain always.
        :param bool disabled: Specify if the rule is disable or not. Defaults to `false`
        :param int most_recently_pulled: retain the most recently pulled n artifacts.
        :param int most_recently_pushed: retain the most recently pushed n artifacts.
        :param int n_days_since_last_pull: retains the artifacts pulled within the lasts n days.
        :param int n_days_since_last_push: retains the artifacts pushed within the lasts n days.
        :param str repo_excluding: For the repositories excuding.
        :param str repo_matching: For the repositories matching.
        :param str tag_excluding: For the tag excuding.
        :param str tag_matching: For the tag matching.
        :param bool untagged_artifacts: with untagged artifacts. Defaults to `true`
               
               > Multiple tags or repositories must be provided as a comma-separated list wrapped into curly brackets `{ }`. Otherwise, the value is interpreted as a single value.
        """
        RetentionPolicyRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            always_retain=always_retain,
            disabled=disabled,
            most_recently_pulled=most_recently_pulled,
            most_recently_pushed=most_recently_pushed,
            n_days_since_last_pull=n_days_since_last_pull,
            n_days_since_last_push=n_days_since_last_push,
            repo_excluding=repo_excluding,
            repo_matching=repo_matching,
            tag_excluding=tag_excluding,
            tag_matching=tag_matching,
            untagged_artifacts=untagged_artifacts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             always_retain: Optional[bool] = None,
             disabled: Optional[bool] = None,
             most_recently_pulled: Optional[int] = None,
             most_recently_pushed: Optional[int] = None,
             n_days_since_last_pull: Optional[int] = None,
             n_days_since_last_push: Optional[int] = None,
             repo_excluding: Optional[str] = None,
             repo_matching: Optional[str] = None,
             tag_excluding: Optional[str] = None,
             tag_matching: Optional[str] = None,
             untagged_artifacts: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'alwaysRetain' in kwargs:
            always_retain = kwargs['alwaysRetain']
        if 'mostRecentlyPulled' in kwargs:
            most_recently_pulled = kwargs['mostRecentlyPulled']
        if 'mostRecentlyPushed' in kwargs:
            most_recently_pushed = kwargs['mostRecentlyPushed']
        if 'nDaysSinceLastPull' in kwargs:
            n_days_since_last_pull = kwargs['nDaysSinceLastPull']
        if 'nDaysSinceLastPush' in kwargs:
            n_days_since_last_push = kwargs['nDaysSinceLastPush']
        if 'repoExcluding' in kwargs:
            repo_excluding = kwargs['repoExcluding']
        if 'repoMatching' in kwargs:
            repo_matching = kwargs['repoMatching']
        if 'tagExcluding' in kwargs:
            tag_excluding = kwargs['tagExcluding']
        if 'tagMatching' in kwargs:
            tag_matching = kwargs['tagMatching']
        if 'untaggedArtifacts' in kwargs:
            untagged_artifacts = kwargs['untaggedArtifacts']

        if always_retain is not None:
            _setter("always_retain", always_retain)
        if disabled is not None:
            _setter("disabled", disabled)
        if most_recently_pulled is not None:
            _setter("most_recently_pulled", most_recently_pulled)
        if most_recently_pushed is not None:
            _setter("most_recently_pushed", most_recently_pushed)
        if n_days_since_last_pull is not None:
            _setter("n_days_since_last_pull", n_days_since_last_pull)
        if n_days_since_last_push is not None:
            _setter("n_days_since_last_push", n_days_since_last_push)
        if repo_excluding is not None:
            _setter("repo_excluding", repo_excluding)
        if repo_matching is not None:
            _setter("repo_matching", repo_matching)
        if tag_excluding is not None:
            _setter("tag_excluding", tag_excluding)
        if tag_matching is not None:
            _setter("tag_matching", tag_matching)
        if untagged_artifacts is not None:
            _setter("untagged_artifacts", untagged_artifacts)

    @property
    @pulumi.getter(name="alwaysRetain")
    def always_retain(self) -> Optional[bool]:
        """
        retain always.
        """
        return pulumi.get(self, "always_retain")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        Specify if the rule is disable or not. Defaults to `false`
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="mostRecentlyPulled")
    def most_recently_pulled(self) -> Optional[int]:
        """
        retain the most recently pulled n artifacts.
        """
        return pulumi.get(self, "most_recently_pulled")

    @property
    @pulumi.getter(name="mostRecentlyPushed")
    def most_recently_pushed(self) -> Optional[int]:
        """
        retain the most recently pushed n artifacts.
        """
        return pulumi.get(self, "most_recently_pushed")

    @property
    @pulumi.getter(name="nDaysSinceLastPull")
    def n_days_since_last_pull(self) -> Optional[int]:
        """
        retains the artifacts pulled within the lasts n days.
        """
        return pulumi.get(self, "n_days_since_last_pull")

    @property
    @pulumi.getter(name="nDaysSinceLastPush")
    def n_days_since_last_push(self) -> Optional[int]:
        """
        retains the artifacts pushed within the lasts n days.
        """
        return pulumi.get(self, "n_days_since_last_push")

    @property
    @pulumi.getter(name="repoExcluding")
    def repo_excluding(self) -> Optional[str]:
        """
        For the repositories excuding.
        """
        return pulumi.get(self, "repo_excluding")

    @property
    @pulumi.getter(name="repoMatching")
    def repo_matching(self) -> Optional[str]:
        """
        For the repositories matching.
        """
        return pulumi.get(self, "repo_matching")

    @property
    @pulumi.getter(name="tagExcluding")
    def tag_excluding(self) -> Optional[str]:
        """
        For the tag excuding.
        """
        return pulumi.get(self, "tag_excluding")

    @property
    @pulumi.getter(name="tagMatching")
    def tag_matching(self) -> Optional[str]:
        """
        For the tag matching.
        """
        return pulumi.get(self, "tag_matching")

    @property
    @pulumi.getter(name="untaggedArtifacts")
    def untagged_artifacts(self) -> Optional[bool]:
        """
        with untagged artifacts. Defaults to `true`

        > Multiple tags or repositories must be provided as a comma-separated list wrapped into curly brackets `{ }`. Otherwise, the value is interpreted as a single value.
        """
        return pulumi.get(self, "untagged_artifacts")


@pulumi.output_type
class RobotAccountPermission(dict):
    def __init__(__self__, *,
                 accesses: Sequence['outputs.RobotAccountPermissionAccess'],
                 kind: str,
                 namespace: str):
        RobotAccountPermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            accesses=accesses,
            kind=kind,
            namespace=namespace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             accesses: Sequence['outputs.RobotAccountPermissionAccess'],
             kind: str,
             namespace: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("accesses", accesses)
        _setter("kind", kind)
        _setter("namespace", namespace)

    @property
    @pulumi.getter
    def accesses(self) -> Sequence['outputs.RobotAccountPermissionAccess']:
        return pulumi.get(self, "accesses")

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")


@pulumi.output_type
class RobotAccountPermissionAccess(dict):
    def __init__(__self__, *,
                 action: str,
                 resource: str,
                 effect: Optional[str] = None):
        RobotAccountPermissionAccess._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            resource=resource,
            effect=effect,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             resource: str,
             effect: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("action", action)
        _setter("resource", resource)
        if effect is not None:
            _setter("effect", effect)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def resource(self) -> str:
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")


@pulumi.output_type
class GetGroupsGroupResult(dict):
    def __init__(__self__, *,
                 group_name: str,
                 group_type: int,
                 id: int,
                 ldap_group_dn: str):
        """
        :param str group_name: The name of the group to filter by.
        :param int group_type: The type of the group.
        :param int id: The ID of the group.
        :param str ldap_group_dn: The LDAP group DN to filter by.
        """
        GetGroupsGroupResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_name=group_name,
            group_type=group_type,
            id=id,
            ldap_group_dn=ldap_group_dn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_name: str,
             group_type: int,
             id: int,
             ldap_group_dn: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'groupName' in kwargs:
            group_name = kwargs['groupName']
        if 'groupType' in kwargs:
            group_type = kwargs['groupType']
        if 'ldapGroupDn' in kwargs:
            ldap_group_dn = kwargs['ldapGroupDn']

        _setter("group_name", group_name)
        _setter("group_type", group_type)
        _setter("id", id)
        _setter("ldap_group_dn", ldap_group_dn)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> str:
        """
        The name of the group to filter by.
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="groupType")
    def group_type(self) -> int:
        """
        The type of the group.
        """
        return pulumi.get(self, "group_type")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The ID of the group.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ldapGroupDn")
    def ldap_group_dn(self) -> str:
        """
        The LDAP group DN to filter by.
        """
        return pulumi.get(self, "ldap_group_dn")


@pulumi.output_type
class GetProjectsProjectResult(dict):
    def __init__(__self__, *,
                 name: str,
                 project_id: int,
                 public: bool,
                 type: str,
                 vulnerability_scanning: bool):
        GetProjectsProjectResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            project_id=project_id,
            public=public,
            type=type,
            vulnerability_scanning=vulnerability_scanning,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             project_id: int,
             public: bool,
             type: str,
             vulnerability_scanning: bool,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']
        if 'vulnerabilityScanning' in kwargs:
            vulnerability_scanning = kwargs['vulnerabilityScanning']

        _setter("name", name)
        _setter("project_id", project_id)
        _setter("public", public)
        _setter("type", type)
        _setter("vulnerability_scanning", vulnerability_scanning)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def public(self) -> bool:
        return pulumi.get(self, "public")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vulnerabilityScanning")
    def vulnerability_scanning(self) -> bool:
        return pulumi.get(self, "vulnerability_scanning")


